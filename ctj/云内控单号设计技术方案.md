# 云内控单号设计技术方案

## 现状

目前单号的功能单一，存在以下问题：

* 同一表达式内只支持单个流水号，
* 不支持自动重置，需要手动操作；
* 单号API每次调用时库表记录增加，存在数据增量风险

## 需求

* 支持自动重置流水号，根据年份月份或其他条件例如单位
* 支持流水号多配置，每个流水号有自己的自增策略

## 解决方案

* 根据前置规则获取或重置流水号。
* 通过唯一索引、数据库锁/分布式锁（锁重试）解决单号获取并发问题

### 库表设计

|​`com_no_config`​<br />|类型|约束|默认值|注释|示例值|
| --------| ------| ----------| --------| ------| --------|
|​`id`​|​`varchar(38)`​|​`not null primary key`​||​`主键id`​|<br />|
|​`bill_type_id`​|​`varchar(38)`​|​`not null`​​<br />||​`单据类型id`​|<br />|
|​`rule_type`​|​`number(1)`​||​`default 0`​|​`规则类型0-表达式1-API`​||
|​`rule_value`​|​`varchar(200)`​|​`not null`​​<br />||​`规则值`​|<br />|
|​`create_user`​|​`varchar(30)`​|||​`创建人`​||
|​`create_time`​|​`varchar(30)`​|​`not null`​||​`创建时间`​||
|​`update_user`​|​`varchar(30)`​|||​`更新人`​||
|​`update_time`​|​`varchar(30)`​|​`not null`​||​`更新时间`​||
|​`is_deleted`​|​`numeric(1)`​|​`not null`​||​`是否删除；1-是2-否`​||

|​`com_no_serial`​<br />|类型|约束|默认值|注释|示例值|
| --------| ------| --------| --------| ------| --------------|
|​`id`​|​`varchar(38)`​|​`not null primary key`​||​`主键ID`​||
|​`rule_id`​|​`varchar(38)`​|​`not null`​||​`单号规则ID`​||
|​`rule_format`​|​`varchar(100)`​|​`not null`​|<br />|​`单号格式常量`​|BX20240115%s|
|​`serial_no`​|​`numeric(20)`​|​`not null`​||​`当前流水号`​||
|​`create_time`​|​`varchar(30)`​|​`not null`​<br />||​`创建时间`​||
|​`update_time`​|​`varchar(30)`​|​`not null`​||​`更新时间`​||
|​`is_deleted`​|​`numeric(1)`​|​`not null`​||​`是否删除；1-是2-否`​||

### 实现思路

基于以上需求实现的主要有以下两个API：单号规则维护，获取单号

**单号规则维护：**

1. 获取前端传递数据报文示例

    ```json
    [
        {
            "key": "const",
            "label": "常量",
            "value": "HT"
        },
        {
            "key": "time",
            "label": "时间",
            "value": "yyyyMMdd"
        },
        {
            "key": "variable",
            "label": "变量",
            "value": "单位"
        },
        {
            "key": "serial",
            "label": "流水号",
            "value": "1(6)"
        }
    ]
    ```

2. 主要保证一个单据类型只能配置一个单号规则，可通过唯一索引解决

**获取单号**：

1. 依据`billTypeID`​​​​​查询单号配置表，获取表达式以及`ruleID`​​​​​
2. 序列化解析表达式，并处理流水号维度（维度是流水号的维度，若维度被包含在单号中，则单号本身就是维度）
3. 循环处理表达式的JSON数组，1. 组装表达式的常量，2. 收集表达式中流水号的JSON对象, 3. 组装`rule_format`​
4. 依据`ruleId`​和`rule_format`​查询单号记录表，获取流水号

    * 流水号为null：获取流水号初始值，保存流水号
    * 流水号不为null：将流水号加一，更新到数据库
5. 返回单号

### 生成与重置

根据现有数据库结构设计，生成与重置的逻辑是一样的。主要通过

* 通过`ruleId`​和`rule_format`​查表
* 未查询到本年或者本月，甚至本日的单号，以及联合维度，本单位本月的流水号，则进行重新初始化

### 并发问题

在整个业务处理过程中，以下两个场景可能存在并发问题

* 保存单号规则时
* 获取单号时 1. 单号累加时 2. 单号生成时/重置时

考虑到可能存在多实例的情况，暂不考虑JVM锁，考虑通过中间件的方式

**数据库层面**

* 唯一索引约束，可以解决insert的并发问题，通过自旋方式进行重试，以及MVCC的机制，使用CAS方式逻辑控制单号自增问题（类似于乐观锁）

  缺点：随机性大，大概率会导致线程更新失败，cpu空转的情况，导致频繁查询数据库

  优点：没有锁竞争

* 事务隔离级别：目前数据库隔离级别为可重复读，可单独设置获取单号事务为SERIALIZABLE

  优点：可以平衡性能和一致性，不会存在并发问题

  缺点：阻塞单号业务所有事务，不同单号规则的事务也会被阻塞，性能很差

**锁层面**

加锁方式：

1. 获取单号的 `ruleId`​与`ruleFormat`​
2. 查询是否存在单号记录
3. 存在单号记录，计算流水号目标值，CAS方式进行更新，更新失败进行重试更新
4. 不存在单号记录

    获取锁成功，再次查询是否存在单号，不存在单号即进行新增，存在即进行修改

    获取锁失败，等待一秒进行重试步骤2

‍

* 分布式锁实现（Redission）

  优点：依据Redission自身的watchDog机制、锁订阅、支持非阻塞获取锁、以及Lua脚本加锁逻辑，不会存在死锁，锁忘记释放，锁失效等问题

  缺点：对于目前的系统架构，缺少对Redission的继承；基于现场环境，存在redis被清掉Allkey，以及redis挂掉的情况

* 数据库排他锁（select for update）

  优点：

  1. 同一单号规则排队获取单号，不用担心锁释放问题，在可重复读的隔离级别下，事务提交则锁释放
  2. 锁超时时间可通过声明式事务进行控制，默认为无限期

  缺点：

  1. 获取锁的会占用该数据库连接，导致该连接处于阻塞等待其他事务释放锁
  2. 每次请求基本打到数据库层面，如果并发量过大，数据库连接可能挂掉

**消息队列**

* Kafka或其他MQ

  优点：使用消息队列或消息中间件可以将并发操作转换为顺序执行的任务。这有助于解耦并发操作，避免直接的竞争条件。

  缺点：鉴于目前现状，成本最大

### 数据迁移

1. 单号配置表只需通过简单insert into select语句进行迁移
2. 单号记录表取最新的单号记录，并通过分组，字段截取进行处理

‍

## 性能测试
